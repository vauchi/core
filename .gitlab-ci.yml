# SPDX-FileCopyrightText: 2026 Mattia Egloff <mattia.egloff@pm.me>
#
# SPDX-License-Identifier: GPL-3.0-or-later

# GitLab CI for vauchi-core
#
# Pipeline strategy:
#   - MR: Validation (lint, test+coverage, security) - runs only on relevant changes
#   - Tags (v*): Build, package, publish releases
#
# Uses shared templates from vauchi/scripts for consistency.
#
# Performance optimizations:
#   - Change-based rules: Jobs run only when relevant files change
#     - Rust lint/test: *.rs, Cargo.toml, Cargo.lock
#     - REUSE lint: LICENSES/, REUSE.toml, LICENSE*
#     - Security audit: Cargo.toml, Cargo.lock (dependencies)
#     - License check: Cargo.*, deny.toml
#   - Test and coverage combined in single pass
#   - Parallel build jobs (iOS + Android)
#   - sccache for shared compilation cache (30-50% faster rebuilds)
#   - mold linker on Linux (2-5x faster linking)
#   - Cargo.lock-based cache keys (smarter invalidation)

# Include shared templates
include:
  - project: 'vauchi/scripts'
    ref: main
    file:
      - '/ci-templates/rust-base.yml'
      - '/ci-templates/security.yml'
      - '/ci-templates/mr-rules.yml'
      - '/ci-templates/release.yml'
      - '/ci-templates/downstream.yml'

stages:
  - lint
  - test
  - security
  - build
  - package
  - publish
  - trigger

# ============================================================
# Lint Stage (MR only, change-based)
# ============================================================

lint:format:
  extends: [.linux-runner, .validation-rust, .timeout-quick]
  stage: lint
  cache:
    policy: pull  # Read-only cache - lint doesn't need to update
  script:
    - rustup component add rustfmt
    - cargo fmt --all -- --check

lint:clippy:
  extends: [.linux-runner, .validation-rust, .timeout-quick]
  stage: lint
  cache:
    policy: pull  # Read-only cache - lint doesn't need to update
  script:
    - rustup component add clippy
    - cargo clippy --all-targets -- -D warnings

lint:reuse:
  extends: [.validation-reuse, .timeout-quick]
  image:
    name: fsfe/reuse:latest
    entrypoint: [""]
  tags: [docker]
  stage: lint
  script:
    - reuse lint

# ============================================================
# Test Stage (MR only, runs on Rust code changes)
# ============================================================

test:
  extends: [.linux-runner, .validation-rust, .timeout-standard]
  stage: test
  before_script:
    - !reference [.self-hosted, before_script]
    - rustup component add llvm-tools-preview
    - cargo install cargo-llvm-cov --locked || true
  script:
    # Run tests with coverage in single pass
    - cargo llvm-cov --workspace --lcov --output-path lcov.info
    - cargo llvm-cov report
  coverage: '/Total:\s+(\d+(?:\.\d+)?%)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: lcov.info
    paths:
      - lcov.info
    expire_in: 1 week

# ============================================================
# Security Stage (MR only, change-based)
# ============================================================

# Rust-specific security audit (runs on dependency changes)
security:audit:
  extends: [.linux-runner, .validation-deps, .timeout-quick]
  stage: security
  cache:
    policy: pull  # Read-only cache
  script:
    - cargo install cargo-audit || true
    - cargo audit

# License compliance via cargo-deny (runs on dependency or deny.toml changes)
security:licenses:
  extends: [.linux-runner, .validation-licenses, .timeout-quick]
  stage: security
  cache:
    policy: pull  # Read-only cache
  script:
    - cargo install cargo-deny || true
    - cargo deny check licenses

# ============================================================
# Build Stage - Tags (release builds)
# ============================================================

# Verify tag is on main branch before proceeding with release
# Overrides .self-hosted SSH clone — tag pipelines need HTTPS checkout
# since the runner may not have gitlab.com in known_hosts
release:verify:
  extends: [.linux-runner, .release-only]
  stage: build
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: "100"
  before_script: []
  script:
    - |
      echo "Verifying tag $CI_COMMIT_TAG is on main branch..."
      git fetch origin main --depth=100
      if git merge-base --is-ancestor "$CI_COMMIT_SHA" origin/main; then
        echo "✓ Tag $CI_COMMIT_TAG is on main branch"
      else
        echo "✗ ERROR: Tag $CI_COMMIT_TAG is NOT on main branch!"
        echo "  Tags must only be created on commits that are on main."
        exit 1
      fi

build:ios:
  extends: [.macos-runner, .release-only, .timeout-extended]
  stage: build
  needs: [release:verify]
  script:
    - ./scripts/build-bindings.sh --ios
  artifacts:
    paths:
      - target/bindings/ios/
    expire_in: 1 day

build:android:
  extends: [.linux-runner, .release-only, .timeout-long]
  stage: build
  needs: [release:verify]
  before_script:
    - !reference [.self-hosted, before_script]
    # Find Android NDK - check common locations
    - |
      for ndk_path in /opt/android-sdk/ndk/* /opt/android-ndk $HOME/Android/Sdk/ndk/*; do
        if [ -d "$ndk_path" ]; then
          export ANDROID_NDK_HOME="$ndk_path"
          echo "Found Android NDK at: $ANDROID_NDK_HOME"
          break
        fi
      done
      if [ -z "$ANDROID_NDK_HOME" ]; then
        echo "ERROR: Android NDK not found. Please install it or set ANDROID_NDK_HOME."
        exit 1
      fi
    - rustup target add aarch64-linux-android x86_64-linux-android
  script:
    - ./scripts/build-bindings.sh --android
  artifacts:
    paths:
      - target/bindings/android/
    expire_in: 1 day

# Validate generated bindings have all expected types
build:validate-bindings:
  extends: [.linux-runner, .release-only]
  stage: build
  needs:
    - job: build:ios
      artifacts: true
    - job: build:android
      artifacts: true
  script:
    - ./scripts/validate-bindings.sh
  allow_failure: false

# ============================================================
# Package Stage (Tags only)
# ============================================================

package:xcframework:
  extends: [.macos-runner, .release-only]
  stage: package
  needs: [build:ios, build:validate-bindings]
  script:
    - ./scripts/package-xcframework.sh "$CI_COMMIT_TAG"
  artifacts:
    paths:
      - dist/VauchiMobileFFI.xcframework.zip
      - dist/VauchiMobileFFI.xcframework.zip.sha256
      - dist/VauchiMobile-*.zip
    expire_in: 1 week

package:android:
  extends: [.linux-runner, .release-only]
  stage: package
  needs: [build:android, build:validate-bindings]
  script:
    - ./scripts/package-android.sh "$CI_COMMIT_TAG"
  artifacts:
    paths:
      - dist/vauchi-mobile-android-*.zip
      - dist/vauchi-mobile-android-*.zip.sha256
    expire_in: 1 week

# ============================================================
# Publish Stage (Tags only)
# ============================================================

publish:packages:
  extends: [.linux-runner, .release-only]
  stage: publish
  needs: [package:xcframework, package:android]
  script:
    - ./scripts/publish-packages.sh "$CI_COMMIT_TAG"

# Publish vauchi-core crate to GitLab package registry
publish:core:
  extends: [.linux-runner, .release-only]
  stage: publish
  needs: [release:verify]
  script:
    - |
      VERSION="${CI_COMMIT_TAG#v}"
      echo "Publishing vauchi-core $VERSION to GitLab package registry..."

      # Package the crate
      cargo package -p vauchi-core --allow-dirty

      # Upload to GitLab generic packages registry
      CRATE_FILE="target/package/vauchi-core-${VERSION}.crate"
      curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file "$CRATE_FILE" \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/vauchi-core/${VERSION}/vauchi-core-${VERSION}.crate"

      echo "✓ Published vauchi-core $VERSION"

# Publish vauchi-mobile crate to GitLab package registry
publish:mobile:
  extends: [.linux-runner, .release-only]
  stage: publish
  needs: [publish:core]
  script:
    - |
      VERSION="${CI_COMMIT_TAG#v}"
      echo "Publishing vauchi-mobile $VERSION to GitLab package registry..."

      # Create tarball manually (cargo package requires vauchi-core on crates.io)
      # Use temp directory to get correct archive structure
      TMPDIR=$(mktemp -d)
      PKG_DIR="$TMPDIR/vauchi-mobile-${VERSION}"
      mkdir -p "$PKG_DIR"

      cp vauchi-mobile/Cargo.toml "$PKG_DIR/"
      cp vauchi-mobile/uniffi-bindgen.rs "$PKG_DIR/"
      cp vauchi-mobile/README.md "$PKG_DIR/"
      cp -r vauchi-mobile/src "$PKG_DIR/"
      cp -r vauchi-mobile/benches "$PKG_DIR/"
      cp -r LICENSES "$PKG_DIR/"

      mkdir -p target/package
      CRATE_FILE="target/package/vauchi-mobile-${VERSION}.crate"
      tar czf "$CRATE_FILE" -C "$TMPDIR" "vauchi-mobile-${VERSION}"
      rm -rf "$TMPDIR"

      # Upload to GitLab generic packages registry
      curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file "$CRATE_FILE" \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/vauchi-mobile/${VERSION}/vauchi-mobile-${VERSION}.crate"

      echo "✓ Published vauchi-mobile $VERSION"

release:create:
  extends: .release-only
  stage: publish
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  tags:
    - docker
  needs: [publish:packages, publish:core, publish:mobile]
  script:
    - echo "Creating release $CI_COMMIT_TAG"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: |
      ## Vauchi $CI_COMMIT_TAG

      ### Rust Crates

      - [vauchi-core](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/vauchi-core/${CI_COMMIT_TAG#v}/vauchi-core-${CI_COMMIT_TAG#v}.crate)
      - [vauchi-mobile](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/vauchi-mobile/${CI_COMMIT_TAG#v}/vauchi-mobile-${CI_COMMIT_TAG#v}.crate)

      ### Mobile Bindings

      - [iOS XCFramework](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/vauchi-mobile/${CI_COMMIT_TAG#v}/VauchiMobileFFI.xcframework.zip)
      - [Android](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/vauchi-mobile/${CI_COMMIT_TAG#v}/vauchi-mobile-android-${CI_COMMIT_TAG#v}.zip)

      ### Integration

      See [documentation](https://gitlab.com/vauchi/core/-/blob/main/README.md) for integration instructions.

# ============================================================
# Trigger Stage (Tags only)
# ============================================================

trigger:downstream:
  extends: [.linux-runner, .release-only]
  stage: trigger
  needs: [release:create]
  script:
    - ./scripts/trigger-downstream.sh "$CI_COMMIT_TAG"

# NOTE: Downstream triggers are handled by trigger:downstream above
# (via trigger-downstream.sh) which uses the Pipeline Trigger API to
# pass UPSTREAM_VERSION to distribution repos. This only runs on tags.
# The trigger:swift-package and trigger:android-package jobs from the
# downstream.yml template are disabled here — they used GitLab's trigger:
# keyword which doesn't pass variables and sets a different pipeline
# source type than what distribution repos expect.

# ============================================================
# Manual Dev Build (on-demand)
# ============================================================

build:dev:
  extends: .linux-runner
  stage: build
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual
  variables:
    DEV_VERSION: "dev-${CI_COMMIT_SHORT_SHA}"
  before_script:
    - !reference [.self-hosted, before_script]
    # Find Android NDK - check common locations
    - |
      for ndk_path in /opt/android-sdk/ndk/* /opt/android-ndk $HOME/Android/Sdk/ndk/*; do
        if [ -d "$ndk_path" ]; then
          export ANDROID_NDK_HOME="$ndk_path"
          echo "Found Android NDK at: $ANDROID_NDK_HOME"
          break
        fi
      done
      if [ -z "$ANDROID_NDK_HOME" ]; then
        echo "ERROR: Android NDK not found. Please install it or set ANDROID_NDK_HOME."
        exit 1
      fi
    - rustup target add aarch64-linux-android x86_64-linux-android
  script:
    - ./scripts/build-bindings.sh --android
    - ./scripts/package-android.sh "$DEV_VERSION"
  artifacts:
    paths:
      - dist/
    expire_in: 3 days

# ============================================================
# Cleanup Stage (scheduled or manual)
# ============================================================
# Runs periodically to clean up runner disk space

cleanup:runner:
  extends: .cleanup-runner
  # Run weekly via scheduled pipeline or manually
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - when: manual
      allow_failure: true
